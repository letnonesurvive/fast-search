[[Профиллировщик]]
## Постановка задачи

Изначальная функция, которую необходимо оптимизировать имеет сигнатуру

```go
func SlowSearch(out io.Writer)
```
Она выполняет задачу поиска пользователей и подсчета кол-ва уникальных имен браузера из JSON Файла. От нас необходимо реализовать функцию 
`func FastSearch(out io.Writer)`, которая значительно улучшит производительность исходной реализации.

Для начала запустим бенчмарки данных функций: будем использовать команду `go test -bench . -benchmem`
![[Pasted image 20250119200356.png]]
Пока что `func FastSearch(out io.Writer)` имеет такую же реализацию как и `SlowSearch()`.

Референсное улучшение выглядит как:
```
BenchmarkSolution-8 500 2782432 ns/op 559910 B/op 10422 allocs/op
```

По условию задания необходимо, чтобы хотя бы один из параметров (ns/op, B/op, allocs/op) был быстрее чем в *BenchmarkSolution* и еще один лучше чем в *BenchmarkSolution* + 20% (fast < solution * 1.2)

## Начальные результаты

#### CPU
Запустим проффилировщик и получим в текстом виде снимок по исходнику.  Для начала будем работать с профилем с CPU.
![[Pasted image 20250119201407.png]]

Отметим сразу горячие точки, которые мы можем наблюдать на поверхности
```go
40ms      21:   fileContents, err := io.ReadAll(file)
40ms      35:           user := make(map[string]interface{})
910ms     37:           err := json.Unmarshal([]byte(line), &user)
1.43s     61:                   if ok, err := regexp.MatchString("Android",...
1.22s     83:                   if ok, err := regexp.MatchString("MSIE",...
```

Построим граф вызовов, полученный с проффилировщика. Львиную долю времени CPU занимает regexp, и также много времени занимает `json.Unmarshal`
![[Screenshot from 2025-01-19 20-17-25.png]]


Также сделаем тоже самое, только для снимка памяти
[[Профиллировщик]]
#### Memory
Выпишем в текстом виде результат выполнения функции SlowSearch. Тип для отчетности выбран по умолчанию **alloc_space** (количество аллоцированных байт).

![[Pasted image 20250119202728.png]]

Также как и для CPU отметим подозрительные места, которые вызывают черезмерную аллокацию памяти, здесь список получился гораздо объемнее:
```go
(flat)    (cum)
1.92MB    21.51MB

1kB                  16:   file, err := os.Open(filePath)
28.50MB              21:   fileContents, err := io.ReadAll(file)
6.06kB               26:   r := regexp.MustCompile("@")
4.92MB    5.05MB     31:   lines := strings.Split(string(fileContents), "\n")
437.50kB  437.50kB   35:   user := make(map[string]interface{})
4.53MB    15.55MB    37:   err := json.Unmarshal([]byte(line), &user)
136.94kB  136.94kB   41:   users = append(users, user)
64.73MB              61:   if ok, err := regexp.MatchString("Android", ...
22.38kB   22.38kB    71:   seenBrowsers = append(seenBrowsers, browser)
41.96MB              83:   if ok, err := regexp.MatchString("MSIE", ...
12.50kB   12.50kB    93:   seenBrowsers = append(seenBrowsers, browser)
68.66kB              104:  email := r.ReplaceAllString(user["email"].(string), )
1.46MB    1.60MB     105:  foundUsers += fmt.Sprintf("
38.12kB   85.62kB    108:  fmt.Fprintln(out, "found 
```
В данном списке используются два столбца, *flat* и *cum*.

* **flat** - это объем памяти, который непосрдественно используется в данной функции, без учета вызовов других функций
* **cum (cumulative)** - это объем памяти, который используется в данной фукнции, включая все вызовы других функций, которые она делает.

Например:
```go
func foo() {
    x := make([]byte, 10) // 10 байт выделяются в foo()
    bar()                 // bar() выделяет ещё 20 байт
}

func bar() {
    y := make([]byte, 20) // 20 байт выделяются в bar()
}
```
То есть в столбце cum для `foo()` будет написано 30байт

Построим граф вызовов, полученный с проффилировщика. 
![[Pasted image 20250119205150.png]]
Пойдем ниже по графу вдоль самой жирной красной стрелке
![[Pasted image 20250119205234.png]]Здесь встречаем вызов `regexp compile`. Также много памяти аллоцирует вызов `io.ReadAll`. Если рассмотрим отдельный блок, то увидим надпись 10504kb of 107522kb. Это означает что сам regexp compile выделяет напрямую память равную 10504kb, что как раз и является flat памятью. А вот кумулитативная память в данном случае равна 107522kb, эти аллокации будут видны ниже по графу и происходят далее по стеку вызовов.
![[Pasted image 20250119205345.png]]

## Более подробное описание того, что делает заданная функция

### Исходное состояние
Напишем здесь основные моменты, которые происходят в функции, для того чтобы понять, какую логику мы должны сохранить и соптимизировать. Первое что происходит это открытие файла и чтение всего его содержимого с помощью вызова `io.ReadAll(file)`. 

Далее мы разбиваем полученное содержимое на строки и итерируемся по ним. Перед циклом создаем мапу `users`, ключом которой будет строка, а значеним `interface{}` - это мапа для хранения всех юзеров, извлеченных из файла.

Итерируясь по строкам мы каждый раз аллоцируем нового юзера через
```go
user := make(map[string]interface{})
```
и делаем десериализацию json'a

Затем итерируемся по массиву пользователей и в отдельных циклах проверяем на регулярные выражения строки =="Android"== и =="MSIE==". Если есть соответствие то проверяем, встречали ли мы такой бразуер раньше. Если нет, то записываем его в отдельный массив уникальных браузеров.

В самом конце выводим число уникальных браузеров и список пользователей, которых мы добавили на основе регулярных выражений и уникальных браузеров.

## Места в коде, которые впервую очередь необходимо исправить

1. Попробовать читать файл не весь целеком, а построчно - что должно уменьшить аллокацию памяти.
2. Попробовать эффективно узнать кол-во строк в файле, чтобы во время аллокации массива `users`  указать капасити для наиболее лучшей аллокации. В таком случае даже должна отпасть необходимость каждый раз аллоцировать нового user для того, чтобы добавить его в слайс, вместо этого уже в проинициализированной памяти мы будем класть десириализованный json объект.
3. Избавиться от двух повторяющихся циклов, в которых используется проверка на регулярные выражения, а в идеале вообще делать все действия в том цикле, которые идет по строчкам файлов.
4. Избавиться от регулярных выражений и заменить на `string.contains` поскольку это более легковесная операция.
5. Использовать мапы вместо массивов для более быстрого поиска по ключу вместо линейного поиска, например слайс `browsers`
6. Использовать Strings.Builder для конкотанации строк вместо +=

## Полученные результаты после первых улучшений

![[Pasted image 20250120213926.png]]

После проведенных улучшений видим заметную разницу в производительности, кол-во повторений выполняемого кода увеличилось в три раза, кол-во аллокаций, кол-во выделяемой памяти уменьшилось также в несколько раз. Однако, код все еще выполняется недостаточно производительно. Воспользуемся проффилировщиком для просмотра узких мест.
#### CPU
Выполнив консольную команду `go tool pprof hw3.test pprof_output/cpu.out`, а затем `list FastSearch()` получим следующие результататы

```go
40ms     36:           user := make(map[string]interface{}, 0)
1.18s    37:           err := json.Unmarshal([]byte(scanner.Text()), &user)
20ms     76:           email := r.ReplaceAllString(user["email"].(string), " [at] ")
```

Очень много времени занимает анмаршалинг json сущностей. В таком случае следующей итерацией подключим библиотеку easyjson к проекту, для более оптимальной десириализации данных.
#### Memory
Для памяти выполним коману go tool `pprof hw3.test pprof_output/mem.out`. Далее получим список мест, где тратиться памяти больше всего. 

```go
.        1.25kB    23: file, err := os.Open(filePath)
.        7.58kB    30: r := regexp.MustCompile("@")
.        40kB      35: for i := 0; scanner.Scan(); i++ {
546.88kB 546.88kB  36: user := make(map[string]interface{}, 0)
5.66MB   25.09MB   37: err := json.Unmarshal([]byte(scanner.Text()), &user)
17.81kB  17.81kB   59: seenBrowsers[browser] = true
96.58kB  96.58kB   67: seenBrowsers[browser] = true
.        477.91kB  76: email := r.ReplaceAllString(user["email"].(string), " [at] " ...
18.27kB  275.55kB  77: foundUsersBuilder.WriteString(fmt.Sprintf("[%d] %s <%s>\n", i ..
47.66kB  76.16kB   80: fmt.Fprintln(out, "found users:\n"+foundUsersBuilder.String())
```

## Добавление easyjson к проекту

Для использования easyjson необходимо создать структуру, в которую мы будем анмаршалить наш JSON. Структура User будет выглядить следующим образом:
```go
package user

//easyjson:json
type User struct {
	Browsers []string `json:"browsers"`
	Company  string   `json:"company"`
	Country  string   `json:"country"`
	Email    string   `json:"email"`
	Job      string   `json:"job"`
	Name     string   `json:"name"`
	Phone    string   `json:"phone"`
}
```

Запустим бенчмарки и заметим значительные улучшения.
![[Pasted image 20250122204250.png]]

Однако этого все еще недостаточно для выполнения задания, поскольку кол-во байтов на операцию и аллокаций на операций превосходит референсные значения.

Откажемся от регулярных выражений при замене `@` на `[at]`, вероятно они отнимают довольно много памяти и аллокации, скорее всего `strings.Replace` будет более легким в исполнении.
Также значительно много производительности анмаршалинг не всех байтов JSON сущности, а для начала только массива браузеров, поскольку в цикле есть условие, что если браузеры не подходят по условию то мы двигаемся дальше.
Напишем вспомогательную функцию, которая делает анмаршалинг JSON только для браузеров, дадим ей название `getBrowserBytes`.  Проведем тесты:
![[Pasted image 20250123194309.png]]

После данных изменений задание можно считать выполненым.